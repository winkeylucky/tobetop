需要掌握的设计模式：
    创建型模式：工厂方法模式、抽象工厂模式、单例模式 原型模式
    结构型模式：适配器模式、装饰器模式、代理模式、外观模式、组合模式
    行为型模式：策略模式、模板方法模式、观察者模式

设计模式的六大规则：
    Demeter原则：最少知道原则，也就是说一个实体应当尽量少的与其他实体之间发生相互作用，使得系统模块性对独立
    开闭原则：
    里氏替换原则：
    依赖注入原则：
    接口分离原则：
    合成复用原则：尽量使用合成、聚合的方式，而不是使用继承
java开发的五大原则（SOLID）：
    S：单一职责原则
    O：开闭原则（对扩展开放，对修改关闭）
    L：里氏替换原则（子类继承父类时，尽量只重写父类的抽象方法）
    I：接口分离原则（尽量接口中的方法都是接口的实现类所需要的方法）
    D：依赖注入（这个是开闭原则的基础，针对接口编程，底层和高层尽量都依赖抽象而不依赖于具体）


单例设计模式：一个类只能构建一个对象
                是否线程安全      是否懒加载       是否防止反射构建
    懒汉模式        否               是               否
    恶汉模式        否               否               否
    双重锁检测       是               是              否
    静态内部类       是               是               否
    枚举            是               否               是

为什么枚举可以防止   反射构建实例破坏单例模式？
    因为 Enum 有语法糖，jvm 会阻止反射获取枚举类的私有构造方法。使用枚举类实现的单例设计模式，还可以在枚举类对象
    被反序列化的时候，保证 反序列化返回的结果是同一对象。对于其他方式实现的单例模式，如果想要做到可序列化，又想要反序列化为同一对象
    则必须实现 readResolve 方法。 todo  readResolve

如何选择？
    不需要懒加载：枚举
      需要懒加载：静态内部类

单例模式的优缺点：
    避免了对共享资源的多重占用，节约系统资源，当需要频繁创建和销毁的对象时，单例模式可以提高系统的性能
    不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态
        单例模式中没有抽象层，因此单例类的扩展有很大的困难。

使用场景：servlet（默认单例）、 spring（默认单例）、线程池、常量、springmvc等


工厂模式：工厂模式是用工厂方法代替 new 操作的一种模式。利用工厂模式可以降低程序的耦合性,
         实现了创建者和调用者分离，工厂模式分为简单工厂、工厂方法、抽象工厂模式

简单工厂模式： 相当于一个工厂中有各种产品，创建在一个类中，客户无需知道具体产品的名称，只需要知道产品类所对应的
             参数即可。
简单工厂模式的优缺点：
    优点：简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的的对象。明确区分了各自的职责和权力，
            有利于系统结构的优化
    缺点：工厂类集中了所有实例的创建逻辑，工厂职责过重，而且但类型过多时不利于系统的扩展维护。

工厂方法模式：又称为 多态性工厂模式。在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类
            去做。该核心类成为一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。
            一般用的比较多的是工厂方法模式

抽象工厂模式：简单的说就是工厂的工厂。抽象工厂可以创建具体工厂，由具体工厂来产生具体产品


代理模式：使用代理对象完成用户请求，屏蔽用户对真实对象的访问

使用场景：springAOP、事务原理、日志打印、权限控制、远程调用、安全代理

代理分类：
    静态代理：静态定义代理类。所谓的静态也就是程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。
                优点：静态代理可以做到在不修改目标对象的功能前提下，对目标功能扩展。
                缺点：代理类和委托类实现相同的接口，同时要实现相同的方法。这样就出现了大量的代码重复。如果一个接口增加了一个方法，
                     除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度

    动态代理：动态生成代理类。
            在运行期间，通过反射机制创建了一个实现一组给定接口的新类。
                jdk生成动态代理的核心api：
                    返回代理类： static Object newProxyInstance(ClassLoader loader, Class [] interfaces, InvocationHandler handler)
                    调用处理器的接口： Object invoke(Object proxy, Method method, Object[] args)，用于集中处理在动态代理类对象上的方法调用，通常
                                    在该方法中实现对目标类的代理访问
                代理对象不需要实现接口，但是目标对象一定要实现接口，否则不能用动态代理

                Cglib代理：也叫做子类代理，通过构建目标子类的方式实现代理，从而实现对目标对象功能的扩展。
                            广泛的被许多AOP框架使用，例如：Spring AOP。底层是通过使用 字节码处理框架ASM 来转换字节码并生成新的子类
                            注意：代理的类不能为final，否则报错，目标对象的方法如果为 final，那么就不会执行

建造者模式：将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
                建造者模式通常包括以下几个角色：
                    Builder：给出一个抽象接口，以规范产品对象的各个组成成分的建造。这个接口规定要实现复杂对象的哪些部分的创建，并不涉及
                                具体的对象部件的创建。
                    ConcreteBuilder：实现Builder接口，针对不同的商业逻辑，具体化复杂对象的各部分的创建。在建造过程完成后，提供产品的实例。
                    Director：调用具体建造者来创建复杂对象的各个部分，在 指导者 中不涉及具体产品的信息，值负责保证对象各部分完整创建或按某种顺序创建
                    Product：要创建的复杂对象

           使用场景：
                1.需要生成的对象具有复杂的内部结构
                2.需要生成的对象内部属性本身相互依赖（如：StringBuilder）

           与工厂模式的区别：
                建造者模式更加关注于 零件的装配的顺序


模板模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。
         模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。
    优点：提高了代码复用性（基于继承），将相同部分的代码放在抽象父类中
         提高了扩展性
         实现了反向控制。通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，实现了反向控制，符合开闭原则
    缺点：每个不同的实现都需要一个子类来实现，导致类的个数增加，从而增加了系统实现的复杂性
    应用场景：Junit单元测试、servlet中关于 doGet、doPost方法的调用、spring中JDBCTemplate等


适配器模式：也叫做包装（wrapper）模式
            适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作

            类适配：   adaptee对象 为 adapter所依赖，适配目标为 adapter的父类（或实现的接口）
                        适合应用于 adapter 想修改的 adaptee 的部分方法 的情况
            对象适配： adaptee类 是 adapter的父类，适配目标为 adapter的父类（或实现的接口）
                        适用于 adapter 想为 adaptee添加新的方法 的情况。但在 adaptee 的方法与 adapter的方法
                        不同名而 实现功能 的情况下，也用 对象适配模式。（例如：火鸡的 gobble 需要 适配成 鸭子的 quack 就用的
                        对象适配模式）
            优点：将目标类和适配者类（adaptee）解耦
                 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端来说是透明的，提高了适配者类的复用性
                 灵活性和扩展性都非常号，负荷开闭原则
            应用场景：Future模式。FutureTask将Future适配为Runnable等


外观模式：隐藏系统的复杂性，并向客户提供了一个客户端可以访问系统的接口。
        这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用
        优点：降低了客户类与子系统类的耦合度，实现了子系统与客户之间的怂耦合关系
             对客户屏蔽了子系统的组件，从而简化了接口，减少了客户处理的对象数目并使子系统的使用更加简单
             降低了原有系统的复杂度和系统中的编译依赖性，并简化了系统在不同平台之间的移植过程
        缺点：在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了开闭原则
             不能很好的限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性


原型模式：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象
        原型模式主要用于对象的复制，它的核心就是 原型类（prototype），prototype类需要具备两个条件：
            实现 Cloneable 接口（在jvm中，只有实现了这个Cloneable接口的类才可以被拷贝）
            重写Object类中的clone方法（返回对象的拷贝）
    应用场景：原型模式多用于创建复杂或者构造耗时的实例，因为这种情况下，复制一个已经存在的实例可以使程序运行更高效（Object
             类的 clone 方法是一个 本地方法，它直接操作内存中的二进制流，所以复制大对象时，性能差别特别明显）。
                    例如：spring框架中的 当bean的初试化类型为prototype时，使用的就是 原型模式
    注意：
            使用 new 操作符号创建对象 和 使用 clone方法复制对象有什么异同呢？
                new 操作符的本意是分配内存。程序执行到 new 操作符时，首先去看操作符后面的类型，因为知道了类型才能知道分配多大的内存空间
                    。分配完内存后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的
                    引用（地址）发布到外部，在外部就可以使用这个引用操作这个对象了
                clone 方法在第一步与 new 操作是相似的，都是分配内存，调用 clone 方法时，分配的内存和源对象（即调用clone方法的对象）相同
                    ，然后再使用源对象中对应的各个域，填充到新对象的域，填充完成后，clone方法返回，一个新的相同的对象被创建，同样可以把这个
                    新对象的引用发布到外部

                这也就是人们说使用原型模式复制对象不会调用类的构造方法，并且clone方法直接无视构造方法的权限（即无论 构造方法的修饰符是 private 还是
                    public，clone方法一定会执行成功）的原因。

            原型模式分为：
                浅克隆（拷贝）：复制出来的对象的所有变量都与原来的对象的所有变量都相同，而所有的 对其他对象的引用仍然指向原来的对象
                深克隆（拷贝）：不仅将变量都复制的一份，将原来的对象的 引用对象也复制了一份。
                    Object类中 clone 方法只能拷贝对象中的 基本数据类型，对于 数组、容器对象、引用对象都不会拷贝
                    如果需要实现 深克隆，必须对原型模式中的数组、容器对象、引用对象另行拷贝。



装饰模式：对已经存在的某些类进行装饰，以此来扩展一些功能
            应用场景：java中的 IO流框架

策略模式：针对一组算法或逻辑，将每一个算法或逻辑封装到具有共同接口的独立的类中，从而使得他们之间相互替换。
            还有一种模式也是关注对算法的封装---就是前面提到的模板方法模式。
            策略模式与模板方法模式的区别在于：策略模式比模板方法模式多了一个单独的封住类 Context（上下文）。在模板方法模式
                中，调用算法的主体在抽象的父类中，而在策略模式中，调用算法的主体则是封装到了Context中，抽象策略Strategy一般是一个接口，目的
                只是为了定义规范，里面一般不包含逻辑。
         优点：由于策略类实现自同一个抽象，所以他们之间可以自由切换
              增加一个新的策略对策略模式来说非常容易，基本上可以在不改变原有代码的基础上进行扩展
              如果不使用策略模式，对于所有算法必须使用条件语句进行连接，通过条件判断来决定使用哪一种算法，是非常
                    不容易维护的。（避免了使用多重条件 if...else , switch case 等）
         缺点：维护各个策略类会给开发带来额外开销，一般来说，策略类数量超过5个，就比较令人头疼了
              必须对客户端（调用者）暴露所有的策略类，因为使用哪种策略是由客户端来决定的，因此客户端必须清楚各种策略适用的情形


观察者模式（又称为 发布（Publish）- 订阅（Subscribe）模式）：属于行为型模式一种，它定义了一种 一对多 的依赖关系，让多个观察这对象同时监听某一个主题
        对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。

        观察者模式中的角色：
            Subject 抽象主题（抽象被观察者），抽象主题角色把所有的观察者对象保存到一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加
                和删除观察者对象。
            ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。
            Observe：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在获得主题更改通知时更新自己。
            ConcreteObserve：具体观察者，实现抽象观察者定义的更新接口，以便在获得主题更改通知时更新自己的状态。

        使用场景：关联行为场景，需要注意的是关联行为是可拆分的，而不是组合关系
                事件多级触发场景
                跨系统的消息交换场景，如消息队列、事件总线的处理机制
        优点：
            解除耦合，让耦合的双方都依赖于抽象，从而使得各自的变换都不会影响另一边的变换
        缺点：
            在应用 观察者模式时需要考虑 开发效率 和 运行效率 的问题。程序中包括一个被观察者，多个观察这，开发
            调试等内容会比较复杂。而且在java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率。
            在这种情况下，一般会采用异步实现。

todo https://juejin.im/post/5c8756e6e51d456cda2e7ff1
todo https://design-patterns.readthedocs.io/zh_CN/latest/