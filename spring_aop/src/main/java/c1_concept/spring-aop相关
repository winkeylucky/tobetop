
通知（advice）：
        就是 aop 时，希望在目标方法处执行的方法（这个方法可以在目标方法前、后 出现）
切点（pointcut）：
        满足我们配置的条件的 目标方法。（比如：名字前面是select开头的才执行我们自定义的通知方法。那么这些select开头的方法就是切点。）
连接点（）：
        连接点可以说是切点的全集。切点是连接点的子集
切面（）：
        切点 + 通知 组成的类

事务的基本特性：
    ACID：
        Atomicity：原子性
        Consistency：一致性
        Isolation：隔离性
        Durability：持久性

原子性 和 一致性 的区别
    可以参考 http://geyifan.cn/2016/07/17/talk-about-transaction/
    原子性 关注 状态，要么全部成功，要么全部失败，不存在部分成功的状态
    一致性 关注 数据的可见性，中间状态的数据外部不可见，只有最初的状态和最终的状态的数据对外可见

事务的4种隔离级别：
        √ 表示可能产生的问题
                                脏读（Dirty Read）  不可重复读（NonRepeatable）    幻读（Phantom Read）
    未提交读（Read uncommitted）      √                   √                           √
    已提交读（Read committed）                            √                           √
    可重复读（Repeatable read）                                                       √
    可串行化（Serializable）

    ps：
        脏读：当一个事务正在访问数据，并对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问使用这个数据。
        不可重复读：在一个事务内，两次读到的数据可能不一样(在两次读取的中间，另外一个事务对数据进行了修改)。
        幻读：当事务不是独立执行时发生的一种现象。事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。

spring事务：
    编程事务：手动事务，自己去 begin、 commit、 rollback
    声明事务：底层通过 编程事务 + 反射机制 进行包装

当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。在 TransactionDefinition中定义了7种传播行为，如下：
Spring事务的7种传播属性(默认为 required)：
    支持当前事务的3种情况
        propagation_required        ： 如果当前存在事务，则加入当前事务，如果当前没有事务，则创建一个新的事务
        propagation_supports        ： 如果当前存在事务，则加入当前事务，如果当前没有事务，则以非事务的方式运行
        propagation_mandatory       ： 如果当前存在事务，则加入当前事务，如果当前没有事务，则抛出异常
    不支持当前事务的3种情况
        propagation_requires_new    ： 创建一个新事务，如果当前存在事务，则将当前事务挂起
        propagation_not_supported   ： 以非事务方式运行，如果当前存在事务，则将当前事务挂起
        propagation_never           ： 以非事务的方式运行，如果当前存在事务，则抛出异常
    其他
        propagation_nested          ： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；
                                       如果当前没有事务，则该取值相当于 required
                                       ps：PROPAGATION_NESTED 是 Spring 所特有的。以 PROPAGATION_NESTED 启动的
                                            事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，
                                            它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事
                                            务不能单独提交。如果熟悉 JDBC 中的保存点（SavePoint）的概念，那嵌套事务就很容易理
                                            解了，其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套
                                            子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。

