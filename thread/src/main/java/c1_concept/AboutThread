进程（process）： 线程的容器，是系统的基本运作单位
线程（thread） ： 操作系统中能够运行调度的最小单位。它被包含在进程之中
                 一条线程指的是进程中一个单一顺序的控制流

多线程能提供系统的运行效率吗？
    不能，只能提高系统资源的利用率。

阻塞（blocking）：一个线程占用了公共资源而没有释放锁，其他线程需要等待该线程释放锁后才能操作公共资源。
                 这种状态就是 阻塞。
非阻塞（Non-Blocking）：线程可以自由运行，没有锁定公共资源，不相互阻塞运行

同步（Synchronous）： 方法一旦被调用，则必须等待方法执行完返回后，才能继续下面的操作
异步（Asynchronous）: 不关心方法的执行过程，触发要调用的方法后，就继续执行下面的操作，不会产生阻塞状态。

并发（Concurrency）：一个时间段内多个任务执行，但不一定是同时在执行，他们可能是交替运行，也可能是串行运行。
并行（Parallelism）: 多个任务同时执行
并发包含并行

多线程运用场景：迅雷多个资源同时下载，多人微信视频聊天

线程的状态和生命周期（java.lang.Thread.State）
    NEW               线程刚刚创建，还没有调用start()
    RUNNABLE          线程调用了 start() 后，状态为 RUNNABLE
    BLOCKED           线程被阻塞，等待获取锁（获取锁后，进入并执行同步代码块中的内容）。如果 碰到synchronized、lock等关键字等占用临界区的情况
                          一旦获取到锁，状态就会改为 RUNNABLE。

    WAITING           线程处于无限制等待状态，等待一个特殊的事件来重新唤醒。
                jdk中的三个例子： 因为 wait() 而等待的线程，可以被 notify()、notifyAll() 唤醒；
                                因为 join() 而等待的线程，等待目标线程执行结束而唤醒；
                                因为 LockSupport 中的 park() 而等待的线程，可以被 unpark() 唤醒
                          唤醒后状态 改为 RUNNABLE 状态
    TIMED_WAITING     线程处于一个有时限的等待，如 sleep(3000),等待3s后线程重新进入 RUNNABLE 状态
    TERMINATED         线程执行完毕后，进入 终止状态
其他的细节：
    wait() 会释放锁和cpu执行权
    sleep() 不会释放锁
    RUNNABLE 详细：线程执行 start() 并不一定会马上执行线程，当线程获得系统的执行权限后才会执行
                  所以，也有人将 RUNNABLE 分为 可执行 、 执行 两种状态
    NEW-->RUNNABLE->TERMINATED 这个过程不可逆
    加深理解：BLOCKED 和 WAITING
            todo 参考 https://www.zhihu.com/question/27654579 失业中的程序猿的回答
             原创链接：https://www.uml-diagrams.org/java-thread-uml-state-machine-diagram-example.html

线程安全：多个线程共享 同一个 全局变量 或 静态变量 ，当他们同时对改变量做 写操作 时，可能会发生数据
         冲突问题，也就是线程安全问题。

多线程间的同步：多个线程共享同一个资源，当其中一个线程对资源进行操作时，不会受到其他线程的干扰


java内存模型（JMM）：是jvm中的一种规范。它用来确保java的并发内存访问操作不会产生歧义。
                    主要目标是定义程序中对各个变量（不同于java编程中所说的变量，这个地方的变量指：实例字段、静态字段、构成数组对象的元素）的访问规则（存储和取出的底层细节）。

                    主内存、工作内存、线程的交互关系如下所示：
                                                                               use->
                            主                           工作内存  <---------------------> 线程
                                    <-store,write                              <-assign
                            内  -----------------------  工作内存  <----> 线程
                                    read,load->
                            存                           工作内存  <----> 线程

                        ps：这里的内存划分 与 jvm内存结构的划分不是一个层次上的划分
                    jmm规定：
                        所有的  变量存储在 主内存（Main Memeory）中
                               每条线程都有自己的 工作内存（Working Memory），工作内存中保存了该线程使用到的 变量的主内存副本拷贝
                                  线程对变量的所有操作（读取、赋值等）必须在工作内存中进行（不能直接读写主内存中的变量）
                                  （ps：被volatile修饰的变量也不例外，所以volatile 不具备原子性,验证可见 VolatileDemo）
                               不同的线程之间无法直接访问对方工作内存中的变量

                    内存间的主要交互操作：
                        这些操作都是原子性（如果某条命令是有多个命令组合而成，则一旦执行这条命令，那么这多个命令必须全部执行完毕）的
                            lock：  作用于主内存的变量，将变量标识为一条线程独占的状态
                            unlock：作用于主内存的变量，将处于lock状态的变量释放出来，释放后的变量可以被其他线程锁定
                            read：  作用于主内存的变量，将主内存的变量的值传送到工作内存中，供 load 操作使用
                            load：  作用于工作内存的变量，将read 传送值存放到 工作内存的变量副本中
                            store： 作用于工作内存的变量，将工作内存中的变量的值传送主内存，供write使用
                            write： 作用于主内存的变量，将store传送的值放入主内存的变量中

                            assign（赋值）：作用于工作内存的变量，将 线程中变量的值 赋给工作内存的变量
                            use          ：作用于工作内存的变量，将 工作内存的变量的值传递给线程中的变量
                        jmm中规定： 将一个变量从主内存中复制到工作内存中只需要顺序执行 read、load 操作
                                   将一个变量从工作内存中复制到主内存中只需要顺序执行 store、write 操作
                             这里只需要顺序执行即可，不一定是连续执行
                                即在 read和load之间可以插入其他操作；
                                store和write之间也可以插入其他操作。
                                例如：对从主内存中的变量a，b进行访问，指令顺序可能是 read a，read b，load b，load a


多线程的三大特性：原子性、可见性、有序性
    原子性：如果说某个操作是原子性的，那么该操作在系统正常运行的情况下一旦执行就不会被任何因素打断
            例如：从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。这2个操作必须要具备原子性才能保证不出现一些意外的问题。
            CAS（CompareAndSwap）操作就是原子级操作
    可见性：当多个线程访问同一个变量时，一个线程修改了变量的值，其他线程能够立刻得到这个修改的值
    有序性：jvm对程序中的各个语句的执行顺序进行重排序后，不会影响执行结果

内置锁：java内置锁通过关键字 Synchronized 实现。当线程进入 Synchronized 修饰的方法或者代码块之前，自动
       获取到锁，代码执行完或抛出异常的时候会自动释放锁。内置锁 为 互斥锁。即如果线程A、B需要访问同一资源，
       如果 线程A获取到锁后，线程B阻塞，直到线程A释放锁，线程B才能获取到锁。
       当synchronized作用于普通方法是，锁对象是this；
       当synchronized作用于静态方法是，锁对象是当前类的Class对象；
       当synchronized作用于代码块时，锁对象是synchronized(obj)中的这个obj，即锁对象可以是任意值。
            内置锁的原理：由底层由 锁对象 调用 wait() 和 notify()
显式锁(ReentrantLock)：
    3个特点：可限时（tryLock（时间，单位））
            可中断（interruptibly（））
            可重入 (可重入：若一个程序或子程序可以在任意时刻被中断，然后操作系统调度执行另外一段代码，这段代码又调
                            用了该子程序不会出错，则称其为：可重入)
            (这个地方得注意：Synchronized 也是可重入锁。例如：
                在一个线程使用synchronized方法时调用该对象另一个synchronized方法，即一个线程得到一个对象锁后再次请求该对象锁，是永远可以拿到锁的)
       另外：可以构造 公平锁

ThreadLocal作用：
    为每一个使用该变量的线程提供一个独立的变量副本，并且不会对其他线程的副本造成影响

数据依赖性：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时
          两个操作之间就存在数据依赖性.数据依赖分以下三种情况：
            写后读 ：例如 a=1; b=a;
            写后写 ：例如 a=1; a=2;
            读后写 ：例如 a=b; b=1;

as-if-serial语义：不管怎么重排序（编译器和处理器为了提高并行读），（单线程）程序的执行结果不会改变
                    为了遵守 as-if-serial语义,编译器和处理器不会对存在数据依赖关系的操作进行重排序

happens-before （先行发生）原则：
    Program Order Rule（程序顺序规则）:在一个线程内按照控制流执行顺序执行（写在前面的先于写在后面的执行）
    Monitor Lock Rule（管程锁定规则）：unlock操作先行发生于后面（时间上的顺序）对 同一个锁 的 lock 操作
    Volatile 变量规则               ：对一个volatile变量的写操作先行发生于后面（时间上的顺序）对这个变量的读操作
    Transitivity（传递性）          ：如果 操作A 先行发生于 操作B，操作B 先行发生于 操作C，则 操作A 先行发生于C
        这四个原则与多线程编程密切相关。其他happens-before原则如下：
    线程启动规则：线程对象的 start() 先行发生于此线程的每个动作
    线程终止规则：线程中的每个动作都先行发生于线程的终止检测（ 可通过 join()方法结束、isAlive()的返回值来检测线程是否已终止执行）
    线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断的线程检测到中断事件发生
    对象终结规则：一个对象的构造函数的执行结束先行发生于 finalize() 方法的开始

悲观锁：获得锁的线程独占锁，其他线程只能依靠阻塞等待当前线程释放锁。
            在 CPU 转换线程阻塞时会引起线程上下文切换，当过多的线程竞争锁时，会引起CPU频繁切换线程上下文，导致低效
乐观锁：每次不加锁，而是假设没有冲突而去完成某项操作，如果因冲突失败就重试，直到成功为止
            乐观锁的实际机制是 CAS（CompareAndSwap） 操作
            乐观锁可能导致ABA问题
                CAS导致的ABA问题如何解决？
                    J.U.C中提供了一个 带有标记的原子引用类 AtomicStampedReference，它通过控制变量值的版本来保证CAS的正确性


Synchronized与Lock的对比：
    1.Synchronized 自动释放锁
        Lock 需要手动释放锁
    2.Synchronized 是由jvm执行
        Lock是API类
    3.Synchronized 是悲观锁
        Lock是了乐观锁

    什么时候使用 Lock？
        1.需要公平锁
        2.需要条件锁
        3.需要中断的时候
        4.需要限时的时候
其他知识点：
    读写锁 ReentrantReadWriteLock
        读锁：new ReentrantReadWriteLock().readLock()
        写锁：new ReentrantReadWriteLock().writeLock()
        当多个线程都是 读操作时，线程都使用读锁，线程间 不互斥阻塞；其他情况都会互斥阻塞。
            （即持有读锁的线程A与另一个持有读锁的线程B不会阻塞互斥，简称 读读不互斥，
               其他情况：读写互斥，写写互斥）

    LockSupport类 提供了线程阻塞原语
        park():   让线程挂起（能响应中断，但不抛出异常；猜测lockInterruptibly()就是利用该方法实现）//todo 待验证
        unpark(): 让线程恢复

队列：
    阻塞队列：当队列是空的时候，从队列中获取元素的操作会被阻塞
             当队列是满的时候，向队列中添加元素会被阻塞

线程池出现的背景：
    为了应对 突然大量爆发线程的场景设计。
    一个线程的生命周期分为：
        T1：线程创建时间
        T2：线程执行时间
        T3：线程销毁时间
        一般而言：针对 T1+T3>T2 的线程创建线程池
线程池的优点：
    1.降低资源消耗
        通过重复利用已创建的线程降低线程创建和销毁造成的消耗
    2.提高响应速度
        当任务到达时，任务可以不需要等待线程创建就能立即执行
    3.提高线程的可管理性
        线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，
        使用线程池可以进行统一分配、调优和监控。但是要合理利用

线程池是利用 BlockingQueue 实现的

线程池如何执行任务？
    1.当线程数 <  核心线程数时，创建线程
    2.当线程数 >= 核心线程数，且任务队列未满时，将任务放入任务队列
    3.当线程数 >= 核心线程数，且任务队列已满时
           如果 线程数 < 最大线程数，创建线程
           如果 线程数 >= 最大线程数，抛出异常，拒绝任务

线程池这些参数的设置与系统的负载有直接的关系：
        tasks：每秒需要处理的最大任务数量
        tasktime：(一个线程)处理一个任务所需要的时间
        responsetime：系统允许任务的最大响应时间，比如每个任务的响应时间不得超过2秒
    参数设置：
        假设系统每秒任务数为100-1000，每个任务耗时0.1秒，每个任务的响应时间不超过2秒：
            corePoolSize = tasks/(1/tasktime) = tasks * tasktime：
                即需要10-100个线程
                具体数据最好根据8020原则，即 80% 情况下每秒系统任务数。如果系统80%情况下每秒任务数
                小于200，则 corePoolSize 可设置为20
            任务队列的长度(queueCapacity) = corePoolSize/tasktime*responsetime=（合适的）tasks*responsetime:
                20/0.1*2=400,即 200*2=400，任务队列的长度可设置为400。
                由上面公式也可以得出，任务队列设置过大，会导致响应时间过长
            maximumPoolSize=(max(tasks)-queueCapacity)/(1/tasktime):
                (1000-400)/10=60,即最大线程数为60
            注意：以上关于线程数量的计算并没有考虑CPU的情况。若结合CPU的情况，比如，当线程数量
                 达到50时，CPU达到100%，则将maxPoolSize设置为60也不合适，此时若系统负载长时
                 间维持在每秒1000个任务，则超出线程池处理能力，应设法降低每个任务的处理时间(tasktime)或者升级设备（增大maxPoolSize）。
    如何合理估算线程池大小？
        如果一台服务器上只部署一个应用并且只有一个线程池，服务器的cpu核心数为n，则：
            如果是 CPU密集型应用，则线程池大小设置为 n+1
            如果是 IO密集型（处于IO的线程或者休眠的线程，均不消耗cpu）应用，则线程池的大小设置为 2n+1
        在IO优化中，这样估算更合理：
            最佳线程数目 = （（线程等待时间+线程的CPU执行时间）/线程的CPU执行时间）* cpu核心数

可重入锁：也叫做递归锁，指的是同一线程外层函数获得锁之后，内层递归函数仍然有获取该锁的代码，但不受影响
         在java环境下 ReentrantLock 和 Synchronized都是可重入锁
         如何实现：
            每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程持有，那么任何线程
            都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计为1。
            此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，
            同时计数器会递增。当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。


AQS 可参考文章：
todo
http://www.wangjialong.cc/2018/04/06/aqs_info/
https://juejin.im/entry/5ae02a7c6fb9a07ac76e7b70